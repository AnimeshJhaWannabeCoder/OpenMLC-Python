from ArduinoBoardDialog import ArduinoBoardDialog
from ArduinoBench import ArduinoBench
from ArduinoStatsDialog import ArduinoStatsDialog

from MLC.GUI.Autogenerated.autogenerated import Ui_BoardConfigurationWindow
from MLC.GUI.Experiment.ArduinoConfigManager.BoardConfigurationWindow import BoardConfigurationWindow
from MLC.arduino import boards
from MLC.arduino.connection.serialconnection import SerialConnection, SerialConnectionConfig
from MLC.arduino.protocol import ProtocolConfig, BuildSerial

from PyQt5.QtWidgets import QMessageBox
from PyQt5.QtCore import QTimer

import serial
import threading


class ArduinoBoardManager:

    def __init__(self, protocol_config, serial_config, parent_win=None):
        self.__setup = protocol_config
        self.__connection_config = serial_config
        self.__main_window = BoardConfigurationWindow(
            self, boards.types, self.__setup, parent=parent_win)
        self.__connectino_status = None
        self.__sch = QTimer()
        self.PARITY_BITS = [serial.PARITY_NONE, serial.PARITY_EVEN,
                            serial.PARITY_EVEN, serial.PARITY_MARK, serial.PARITY_SPACE]
        self.STOP_BITS = [
            serial.STOPBITS_ONE, serial.STOPBITS_ONE_POINT_FIVE, serial.STOPBITS_TWO]
        self.BYTE_SIZE = [
            serial.EIGHTBITS, serial.FIVEBITS, serial.SIXBITS, serial.SEVENBITS]

    def get_protocol_config(self):
        return self.__setup

    def get_connection_config(self):
        current_setup = self.__main_window.checkout_connection_config()
        config = SerialConnectionConfig(port=current_setup["port"],
                                        baudrate=current_setup["baudrate"],
                                        parity=self.PARITY_BITS[current_setup["parity"]],
                                        stopbits=self.STOP_BITS[current_setup["stopbits"]],
                                        bytesize=self.BYTE_SIZE[current_setup["bytesize"]])
        return config

    def start_connection(self):
        # TODO Este metodo debe estar enlazado a la opcion de conexion serie
        self.__connection_config = self.get_connection_config()

        return SerialConnection(**self.__connection_config._asdict())

    def start(self):
        self.__main_window.show()
        self.__sch.start()

    def insert_digital_pin(self, pin_index, pin, type_idx):
        if pin_index < 0:
            return

        current = self.__main_window.get_current_board()["DIGITAL_PINS"] if type_idx != 2 else \
            self.__main_window.get_current_board()["PWM_PINS"]
        target_pin = self.__setup.digital_input_pins if type_idx == 0 else \
            self.__setup.digital_output_pins if type_idx == 1 else self.__setup.pwm_pins

        if pin in current and pin not in self.__setup.digital_input_pins and pin not in self.__setup.digital_output_pins \
           and pin not in self.__setup.pwm_pins:
            target_pin.append(pin)
            self.__main_window.addDigitalPin(pin_index, type_idx)
        else:
            self.show_error(
                "Error", "Assign error", "Could not set pin %s with the selected type" % (pin),
                 QMessageBox.Critical, QMessageBox.Ok)

    # Mover a la vista
    def show_error(self, title, text, info, icon, buttons):
        msg = QMessageBox()
        msg.setIcon(icon)
        msg.setText(text)
        msg.setInformativeText(info)
        msg.setWindowTitle(title)
        msg.setStandardButtons(buttons)
        return msg.exec_()

    def remove_digital_pin(self, pin):
        if pin in self.__setup.digital_input_pins:
            self.__setup.digital_input_pins.remove(pin)
  
        if pin in self.__setup.digital_output_pins:
            self.__setup.digital_output_pins.remove(int(pin))

        if pin in self.__setup.pwm_pins:
            self.__setup.pwm_pins.remove(int(pin))

    def insert_analog_pin(self, pin_index, pin, type_idx):
        if pin_index < 0:
            return
        current = self.__main_window.get_current_board()["ANALOG_PINS"]
        target_pin = self.__setup.analog_input_pins if type_idx == 0 else self.__setup.analog_output_pins

        if pin in current and pin not in self.__setup.analog_input_pins and pin not in self.__setup.analog_output_pins:
            target_pin.append(pin)
            self.__main_window.addAnalogPin(pin_index, type_idx)
        else:
            self.show_error(
                "Error", "Assign error", "Could not set pin %d with the selected type" % (pin), QMessageBox.Critical, QMessageBox.Ok)

    def remove_analog_pin(self, pin):
        if pin in self.__setup.analog_input_pins:
            self.__setup.analog_input_pins.remove(pin)

        if pin in self.__setup.analog_output_pins: 
            self.__setup.analog_output_pins.remove(pin)

    def check_connection(self):
        self.__connection_status = self.__main_window.create_connection_dialog(
        )
        conn_checker = threading.Thread(target=self.conn_check)
        conn_checker.start()
        # self.__sch.push_task(self.dummy_conn_check)
        # self.__sch.timeout.connect(self.dummy_conn_check)
        # self.__sch.start(100)
        self.__connection_status.exec_()
        conn_checker.join()

    def conn_check(self):
        try:
            conn = self.start_connection()
            config = ProtocolConfig(conn)
            arduino_if = BuildSerial(config)
            version = arduino_if.get_version()
            self.__connection_status.set_ok()
        except serial.SerialTimeoutException:
            self.__connection_status.set_error("Error: connection timeout")
        except serial.SerialException:
            self.__connection_status.set_error("Error: Board unreachable")

    def board_changed(self, new_idx, old_idx):
        ret = QMessageBox.Yes

        if self.__setup.digital_input_pins or self.__setup.digital_output_pins or \
           self.__setup.analog_input_pins or self.__setup.analog_output_pins or self.__setup.pwm_pins:
            ret = self.show_error(
                "Warning", "Configuration reset", "Changing the board will reset all I/O pins configuration! Continue?", QMessageBox.Critical, QMessageBox.Yes | QMessageBox.No)

        if (ret == QMessageBox.Yes):
            del self.__setup.digital_input_pins[:]
            del self.__setup.digital_output_pins[:]
            del self.__setup.analog_input_pins[:]
            del self.__setup.analog_output_pins[:]
            del self.__setup.pwm_pins[:]
            self.__main_window.set_board(new_idx)
            self.__main_window.update()
        else:
            self.__main_window.set_board(old_idx)

    def start_bench(self):
        try:
            self.__setup = self.__setup._replace(connection=self.start_connection(), **self.__main_window.checkout_board_setup())
        except serial.SerialException:
            self.show_error(
                "Error", "Connection failure", "Could not start connection to board", QMessageBox.Critical, QMessageBox.Ok)
            return
            
        bench = ArduinoBench()
        stats = ArduinoStatsDialog(bench)
        stats.connect_to_reset(bench)
        bench.add_observer(stats)
        bench.start(self.__setup)
        stats.exec_()
        bench.stop()


class EventScheduler:

    def __init__(self):
        self.stopped = False
        self.queue = []
        self.tasks_presents = threading.Condition()

    def start(self):
        self.thread = threading.Thread(target=self.svc)
        self.thread.start()

    def svc(self):
        while(not self.stopped):
            with self.tasks_presents:
                if not self.queue and not self.stopped:
                    self.tasks_presents.wait()
                else:
                    for i in self.queue:
                        i()
                    del self.queue[:]

    def push_task(self, task):
        with self.tasks_presents:
            self.queue.append(task)
            self.tasks_presents.notify()

    def stop(self):
        with self.tasks_presents:
            self.stopped = True
            self.tasks_presents.notify()
        self.thread.join()
