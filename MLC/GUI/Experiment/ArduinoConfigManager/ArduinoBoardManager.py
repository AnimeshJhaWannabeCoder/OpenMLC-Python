from ArduinoBoardDialog import ArduinoBoardDialog
from MLC.GUI.Autogenerated.autogenerated import Ui_BoardConfigurationWindow
from MLC.GUI.Experiment.ArduinoConfigManager.BoardConfigurationWindow import BoardConfigurationWindow
from MLC.arduino import boards

from PyQt5.QtWidgets import QMessageBox
from PyQt5.QtCore import QTimer

class ArduinoBoardManager:
   def __init__(self, parent_win=None):
      self.__setup = BoardSetup()
      self.__main_window = BoardConfigurationWindow(self, boards.types, self.__setup, parent=parent_win)
      self.__connectino_status = None
      #self.__sch = EventScheduler()
      self.__sch = QTimer()
   
   def start(self):
      self.__main_window.show()
      self.__sch.start()

   def insert_digital_pin(self, pin_index, pin, type_idx):
      if pin_index < 0:
         return
      current = self.__main_window.get_current_board()["DIGITAL_PINS"] if type_idx <> 2 else \
                self.__main_window.get_current_board()["PWM_PINS"]
      target_pin = self.__setup.digital_input_pins if type_idx == 0 else \
                   self.__setup.digital_output_pins if type_idx == 1 else self.__setup.pwm_pins
      
      if pin in current and pin not in self.__setup.digital_input_pins and pin not in self.__setup.digital_output_pins \
         and pin not in self.__setup.pwm_pins:
         target_pin.append(pin)
         self.__main_window.addDigitalPin(pin_index, type_idx)
      else:
         self.show_error("Error", "Assign error", "Could not set pin %d with the selected type" % (pin), \
              QMessageBox.Critical, QMessageBox.Ok)

   # Mover a la vista
   def show_error(self, title, text, info, icon, buttons):
      msg = QMessageBox()
      msg.setIcon(icon)
      msg.setText(text)
      msg.setInformativeText(info)
      msg.setWindowTitle(title)
      msg.setStandardButtons(buttons)
      return msg.exec_()
  
   def remove_digital_pin(self, pin_index):
      return

   def insert_analog_pin(self, pin_index, pin, type_idx):
      if pin_index < 0:
         return
      current = self.__main_window.get_current_board()["ANALOG_PINS"] 
      target_pin = self.__setup.analog_input_pins if type_idx == 0 else self.__setup.analog_output_pins

      if pin in current and pin not in self.__setup.analog_input_pins and pin not in self.__setup.analog_output_pins:
         target_pin.append(pin)
         self.__main_window.addAnalogPin(pin_index, type_idx)
      else:
         self.show_error("Error", "Assign error", "Could not set pin %d with the selected type" % (pin))

   def remove_analog_pin(self, pin_index):
      return

   def check_connection(self):
      self.__connection_status = self.__main_window.create_connection_dialog()
      #self.__sch.push_task(self.dummy_conn_check)
      self.__sch.timeout.connect(self.dummy_conn_check)
      self.__sch.start(5000)
      self.__connection_status.exec_() 

   def dummy_conn_check(self):
      self.__connection_status.set_ok()
   
   def board_changed(self, new_idx, old_idx):
      ret = QMessageBox.Yes

      if self.__setup.digital_input_pins or self.__setup.digital_output_pins or \
         self.__setup.analog_input_pins or self.__setup.analog_output_pins or self.__setup.pwm_pins:
         ret = self.show_error("Warning", "Configuration reset", "Changing the board will reset all I/O pins configuration! Continue?"\
         , QMessageBox.Critical, QMessageBox.Yes | QMessageBox.No)

      if (ret == QMessageBox.Yes):
         del self.__setup.digital_input_pins[:]
         del self.__setup.digital_output_pins[:]
         del self.__setup.analog_input_pins[:]
         del self.__setup.analog_output_pins[:]
         del self.__setup.pwm_pins[:]
         self.__main_window.set_board(new_idx)
         self.__main_window.update()
      else:
         self.__main_window.set_board(old_idx)
      

class BoardSetup:
   def __init__(self):
      self.digital_input_pins = []
      self.digital_output_pins = []
      self.analog_input_pins = []
      self.analog_output_pins = []
      self.pwm_pins = []
      self.thread = None

import threading

class EventScheduler:
   def __init__(self):
      self.stopped = False
      self.queue = []
      self.tasks_presents = threading.Condition()

   def start(self):
      self.thread = threading.Thread(target=self.svc) 
      self.thread.start()

   def svc(self):
      while(not self.stopped):
         with self.tasks_presents:
            if not self.queue and not self.stopped:
               self.tasks_presents.wait()
            else:
               for i in self.queue:
                  i()
               del self.queue[:]

   def push_task(self,task):
      with self.tasks_presents:
         self.queue.append(task)
         self.tasks_presents.notify()
   
   def stop(self):
      with self.tasks_presents:
         self.stopped = True
         self.tasks_presents.notify()
      self.thread.join()
      
