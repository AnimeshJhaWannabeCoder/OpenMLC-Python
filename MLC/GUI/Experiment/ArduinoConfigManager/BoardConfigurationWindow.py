import os
import sys

from PyQt5.QtWidgets import QMainWindow
from PyQt5.QtWidgets import QTableWidgetItem
from PyQt5 import QtCore

from MLC.GUI.Autogenerated.autogenerated import Ui_BoardConfigurationWindow
from MLC.GUI.Experiment.ArduinoConfigManager.ArduinoBoardDialog import ArduinoBoardDialog
from MLC.GUI.Experiment.ArduinoConfigManager.ArduinoConnectionDialog import ArduinoConnectionDialog

from MLC.GUI.Experiment.ArduinoConfigManager.Common import create_local_full_path


class BoardConfigurationWindow(QMainWindow):

    def __init__(self, controller, boards, setup, parent=None):
        super(BoardConfigurationWindow, self).__init__(parent)
        self.ui = Ui_BoardConfigurationWindow()
        self.ui.setupUi(self)
        self.ui.arduinoBoard.clear()
        self.__controller = controller
        self.__boards = boards
        self.__setup = setup
        self.__board_idx = 0

        for i in boards:
            self.setup_board(
                self.__board_idx, i["NAME"], i["SHORT_NAME"] + ".png")
            self.__board_idx += 1

        self.__board_idx = 0
        self.ui.arduinoBoard.setCurrentIndex(self.__board_idx)

        self.update()
        self.ui.arduinoBoard.currentIndexChanged.connect(self.index_change)

    def update(self):
        aux_idx = 0
        self.ui.digitalPins.clear()
        digital_pin_count = len(
            self.__boards[self.ui.arduinoBoard.currentIndex()]["DIGITAL_PINS"])
        for i in self.__boards[self.ui.arduinoBoard.currentIndex()]["DIGITAL_PINS"]:
            if i not in self.__setup.digital_input_pins and i not in self.__setup.digital_output_pins and i not in self.__setup.pwm_pins:
                self.setup_pin(self.ui.digitalPins, 0, "Pin " + str(i), i)
            aux_idx += 1

        aux_idx = 0
        self.ui.analogPins.clear()
        for i in self.__boards[self.ui.arduinoBoard.currentIndex()]["ANALOG_PINS"]:
            if i not in self.__setup.analog_input_pins and i not in self.__setup.analog_output_pins:
                self.setup_pin(
                    self.ui.analogPins, 0, "Pin A" + str(i - digital_pin_count), i)
            aux_idx += 1

        for i in xrange(self.ui.digitalPinsList.rowCount(), -1, -1):
            self.ui.digitalPinsList.removeRow(i)

        for i in xrange(self.ui.analogPinList.rowCount(), -1, -1):
            self.ui.analogPinList.removeRow(i)

        for pin in self.__setup.digital_input_pins:
            self.insertPin(pin, 0, self.ui.digitalPinsList)

        for pin in self.__setup.digital_output_pins:
            self.insertPin(pin, 0, self.ui.digitalPinsList)

    def setup_board(self, index, board_name, image_name):
        _translate = QtCore.QCoreApplication.translate
        image_path = create_local_full_path("images", image_name)
        variant = QtCore.QVariant(image_path)
        item_name = _translate("BoardConfigurationWindow", board_name)
        self.ui.arduinoBoard.insertItem(index, item_name, variant)

    def setup_pin(self, combo, index, pin_name, pin_value):
        _translate = QtCore.QCoreApplication.translate
        variant = QtCore.QVariant(pin_value)
        item_name = _translate("BoardConfigurationWindow", pin_name)
        combo.insertItem(index, item_name, variant)

    def showPinout(self):
        index = self.ui.arduinoBoard.currentIndex()
        path = self.ui.arduinoBoard.itemData(index)
        dialog = ArduinoBoardDialog(path)
        dialog.exec_()

    def checkout_config(self):
        # TODO Renombrar para checkout de parametros de conexion serie
        serial_config = {
            "baudrate": int(self.ui.baud_rate_selector.currentText()),
                        "parity": self.ui.parity_bits_selector.currentIndex(),
                        "stopbits": self.ui.stop_bits_selector.currentIndex(),
                        "bytesize": self.ui.byte_size_selector.currentIndex(),
                        "port": self.ui.serial_interface_input.displayText()}
        return serial_config

    def checkConnection(self):
        self.__controller.check_connection()

    def create_connection_dialog(self):
        dialog = ArduinoConnectionDialog()
        return dialog

    def get_current_board(self):
        return self.__boards[self.ui.arduinoBoard.currentIndex()]

    def insertDigitalPin(self):
        idx = self.ui.digitalPins.currentIndex()
        self.__controller.insert_digital_pin(
            idx, self.ui.digitalPins.itemData(idx), self.ui.digitalPinType.currentIndex())
        # self.insertPin(self.ui.digitalPins, self.ui.digitalPinType,
        # self.ui.digitalPinsList)

    def insertAnalogPin(self):
        idx = self.ui.analogPins.currentIndex()
        self.__controller.insert_analog_pin(
            idx, self.ui.analogPins.itemData(idx), self.ui.analogPinType.currentIndex())
        # self.insertPin(self.ui.analogPins, self.ui.analogPinType,
        # self.ui.analogPinList)

    def addDigitalPin(self, pin, pinType):
        self.insertPin(pin, self.ui.digitalPins.itemText(pin),
                       self.ui.digitalPinType.itemText(pinType), self.ui.digitalPinsList)
        self.ui.digitalPins.removeItem(pin)

    def addAnalogPin(self, pin, pinType):
        self.insertPin(pin, self.ui.analogPins.itemText(pin),
                       self.ui.analogPinType.itemText(pinType), self.ui.analogPinList)
        self.ui.analogPins.removeItem(pin)

    def removeDigitalPin(self):
        # FIXME: Llevar al controller la logica de eliminacion
        row = self.ui.digitalPinsList.currentRow()
        if row >= 0:
            pin = self.ui.digitalPinsList.item(row, 0).text()[4:]
            self.ui.digitalPinsList.removeRow(row)
            try:
                self.__setup.digital_input_pins.remove(int(pin))
            except:
                pass
            try:
                self.__setup.digital_output_pins.remove(int(pin))
            except:
                pass
            try:
                self.__setup.pwm_pins.remove(int(pin))
            except:
                pass
            self.setup_pin(self.ui.digitalPins, 0, "Pin " + str(pin), pin)

    def removeAnalogPin(self):
        # FIXME: Llevar al controller la logica de eliminacion
        row = self.ui.analogPinList.currentRow()
        if row >= 0:
            pin = self.ui.analogPinList.item(row, 0).text()[4:]
            self.ui.analogPinList.removeRow(row)
            try:
                self.__setup.analog_input_pins.remove(int(pin))
            except:
                pass
            try:
                self.__setup.analog_output_pins.remove(int(pin))
            except:
                pass
            self.setup_pin(self.ui.analogPins, 0, "Pin " + str(pin), pin)

        return

    def insertPin(self, pin, pinText, pinType, pinsList):
        row = pinsList.rowCount()
        if pin < 0:
            return
        pinsList.insertRow(row)
        widget = QTableWidgetItem(pinText)
        widget.setFlags(QtCore.Qt.ItemIsSelectable | QtCore.Qt.ItemIsEnabled)
        pinsList.setItem(row, 0, widget)
        widget = QTableWidgetItem(pinType)
        widget.setFlags(QtCore.Qt.ItemIsSelectable | QtCore.Qt.ItemIsEnabled)
        pinsList.setItem(row, 1, widget)
        pinsList.verticalHeader().setVisible(False)

    def index_change(self, new_idx):
        self.__controller.board_changed(new_idx, self.__board_idx)

    def set_board(self, idx):
        self.ui.arduinoBoard.blockSignals(True)
        self.ui.arduinoBoard.setCurrentIndex(idx)
        self.ui.arduinoBoard.blockSignals(False)

    def on_bench_test_click(self):
        self.__controller.start_bench()

    def on_connection_type_toggle(self):
        print "Type toggled!"
